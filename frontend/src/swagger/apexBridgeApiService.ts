/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

import { BaseClient } from "./BaseClient";
// ReSharper disable InconsistentNaming

export class SettingsControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get bridge settings
     * @return OK - Returns the configuration settings.
     */
    get(): Promise<SettingsResponseDto> {
        let url_ = this.baseUrl + "/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SettingsResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingsResponseDto>(<any>null);
    }
}

export class TransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Create a bridging transaction
     * @return OK - Returns the raw transaction data, transaction hash, and calculated bridging fee and amounts.
     */
    createCardano(body: CreateTransactionDto): Promise<CreateCardanoTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/createCardano";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCardano(_response);
        });
    }

    protected processCreateCardano(response: Response): Promise<CreateCardanoTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCardanoTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while creating bridging transaction.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateCardanoTransactionResponseDto>(<any>null);
    }

    /**
     * Get fees required for a bridging transaction
     * @return OK - Returns calculated fees.
     */
    getCardanoTxFee(body: CreateTransactionDto): Promise<CardanoTransactionFeeResponseDto> {
        let url_ = this.baseUrl + "/transaction/getCardanoTxFee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCardanoTxFee(_response);
        });
    }

    protected processGetCardanoTxFee(response: Response): Promise<CardanoTransactionFeeResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardanoTransactionFeeResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while getting bridging transaction fees.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardanoTransactionFeeResponseDto>(<any>null);
    }

    /**
     * @return Success
     */
    createEth(body: CreateTransactionDto): Promise<CreateEthTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/createEth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateEth(_response);
        });
    }

    protected processCreateEth(response: Response): Promise<CreateEthTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEthTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateEthTransactionResponseDto>(<any>null);
    }

    /**
     * Confirm the bridging transaction submission on the source chain
     * @return OK - Returns confirmed bridging transaction.
     */
    bridgingTransactionSubmitted(body: TransactionSubmittedDto): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/transaction/bridgingTransactionSubmitted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBridgingTransactionSubmitted(_response);
        });
    }

    protected processBridgingTransactionSubmitted(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while confirming transaction submittion.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(<any>null);
    }
}

export class BridgeTransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get the bridging transaction details
     * @return OK - Returns bridging transaction.
     */
    get(id: number): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found - Bridging transaction not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(<any>null);
    }

    /**
     * Get multiple bridging transactions with filtering and pagination
     * @return OK - Returns bridging transactions.
     */
    getAllFiltered(body: BridgeTransactionFilterDto): Promise<BridgeTransactionResponseDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllFiltered(_response);
        });
    }

    protected processGetAllFiltered(response: Response): Promise<BridgeTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionResponseDto>(<any>null);
    }
}

export class ContactControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Submit a contact message
     * @return OK - Message submitted.
     */
    submitContactForm(body: CreateContactDto): Promise<void> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSubmitContactForm(_response);
        });
    }

    protected processSubmitContactForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class LockedTokensControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get locked tokens amount
     * @return OK - Get locked tokens amount.
     */
    get(): Promise<LockedTokensDto> {
        let url_ = this.baseUrl + "/lockedTokens";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LockedTokensDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LockedTokensDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LockedTokensDto>(<any>null);
    }
}

export class NativeTokenDto implements INativeTokenDto {
    /** Destination chain ID */
    dstChainID!: string;
    /** Native token name */
    tokenName!: string;

    constructor(data?: INativeTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dstChainID = _data["dstChainID"];
            this.tokenName = _data["tokenName"];
        }
    }

    static fromJS(data: any): NativeTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new NativeTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dstChainID"] = this.dstChainID;
        data["tokenName"] = this.tokenName;
        return data; 
    }
}

export interface INativeTokenDto {
    /** Destination chain ID */
    dstChainID: string;
    /** Native token name */
    tokenName: string;
}

export class BridgingSettingsDto implements IBridgingSettingsDto {
    /** For each chain, the minimum fee required to cover the submission of the transaction on the destination chain */
    minChainFeeForBridging!: { [key: string]: number; };
    /** For each chain, the minimum fee required to cover operational costs */
    minOperationFee!: { [key: string]: number; };
    /** For each chain, the minimum allowed UTXO value */
    minUtxoChainValue!: { [key: string]: number; };
    /** Minimum value allowed to be bridged */
    minValueToBridge!: number;
    /** Maximum amount of currency allowed to be bridged */
    maxAmountAllowedToBridge!: string;
    /** Maximum amount of native tokens allowed to be bridged */
    maxTokenAmountAllowedToBridge!: string;
    /** Maximum number of receivers allowed in a bridging request */
    maxReceiversPerBridgingRequest!: number;

    constructor(data?: IBridgingSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.minChainFeeForBridging = {};
            this.minOperationFee = {};
            this.minUtxoChainValue = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["minChainFeeForBridging"]) {
                this.minChainFeeForBridging = {} as any;
                for (let key in _data["minChainFeeForBridging"]) {
                    if (_data["minChainFeeForBridging"].hasOwnProperty(key))
                        this.minChainFeeForBridging![key] = _data["minChainFeeForBridging"][key];
                }
            }
            if (_data["minOperationFee"]) {
                this.minOperationFee = {} as any;
                for (let key in _data["minOperationFee"]) {
                    if (_data["minOperationFee"].hasOwnProperty(key))
                        this.minOperationFee![key] = _data["minOperationFee"][key];
                }
            }
            if (_data["minUtxoChainValue"]) {
                this.minUtxoChainValue = {} as any;
                for (let key in _data["minUtxoChainValue"]) {
                    if (_data["minUtxoChainValue"].hasOwnProperty(key))
                        this.minUtxoChainValue![key] = _data["minUtxoChainValue"][key];
                }
            }
            this.minValueToBridge = _data["minValueToBridge"];
            this.maxAmountAllowedToBridge = _data["maxAmountAllowedToBridge"];
            this.maxTokenAmountAllowedToBridge = _data["maxTokenAmountAllowedToBridge"];
            this.maxReceiversPerBridgingRequest = _data["maxReceiversPerBridgingRequest"];
        }
    }

    static fromJS(data: any): BridgingSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgingSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.minChainFeeForBridging) {
            data["minChainFeeForBridging"] = {};
            for (let key in this.minChainFeeForBridging) {
                if (this.minChainFeeForBridging.hasOwnProperty(key))
                    data["minChainFeeForBridging"][key] = this.minChainFeeForBridging[key];
            }
        }
        if (this.minOperationFee) {
            data["minOperationFee"] = {};
            for (let key in this.minOperationFee) {
                if (this.minOperationFee.hasOwnProperty(key))
                    data["minOperationFee"][key] = this.minOperationFee[key];
            }
        }
        if (this.minUtxoChainValue) {
            data["minUtxoChainValue"] = {};
            for (let key in this.minUtxoChainValue) {
                if (this.minUtxoChainValue.hasOwnProperty(key))
                    data["minUtxoChainValue"][key] = this.minUtxoChainValue[key];
            }
        }
        data["minValueToBridge"] = this.minValueToBridge;
        data["maxAmountAllowedToBridge"] = this.maxAmountAllowedToBridge;
        data["maxTokenAmountAllowedToBridge"] = this.maxTokenAmountAllowedToBridge;
        data["maxReceiversPerBridgingRequest"] = this.maxReceiversPerBridgingRequest;
        return data; 
    }
}

export interface IBridgingSettingsDto {
    /** For each chain, the minimum fee required to cover the submission of the transaction on the destination chain */
    minChainFeeForBridging: { [key: string]: number; };
    /** For each chain, the minimum fee required to cover operational costs */
    minOperationFee: { [key: string]: number; };
    /** For each chain, the minimum allowed UTXO value */
    minUtxoChainValue: { [key: string]: number; };
    /** Minimum value allowed to be bridged */
    minValueToBridge: number;
    /** Maximum amount of currency allowed to be bridged */
    maxAmountAllowedToBridge: string;
    /** Maximum amount of native tokens allowed to be bridged */
    maxTokenAmountAllowedToBridge: string;
    /** Maximum number of receivers allowed in a bridging request */
    maxReceiversPerBridgingRequest: number;
}

export class SettingsResponseDto implements ISettingsResponseDto {
    /** Specifies the current operating mode of the application */
    runMode!: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens!: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings!: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains!: string[];

    constructor(data?: ISettingsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cardanoChainsNativeTokens = {};
            this.bridgingSettings = new BridgingSettingsDto();
            this.enabledChains = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.runMode = _data["runMode"];
            if (_data["cardanoChainsNativeTokens"]) {
                this.cardanoChainsNativeTokens = {} as any;
                for (let key in _data["cardanoChainsNativeTokens"]) {
                    if (_data["cardanoChainsNativeTokens"].hasOwnProperty(key))
                        this.cardanoChainsNativeTokens![key] = _data["cardanoChainsNativeTokens"][key] ? _data["cardanoChainsNativeTokens"][key].map((i: any) => NativeTokenDto.fromJS(i)) : [];
                }
            }
            this.bridgingSettings = _data["bridgingSettings"] ? BridgingSettingsDto.fromJS(_data["bridgingSettings"]) : new BridgingSettingsDto();
            if (Array.isArray(_data["enabledChains"])) {
                this.enabledChains = [] as any;
                for (let item of _data["enabledChains"])
                    this.enabledChains!.push(item);
            }
        }
    }

    static fromJS(data: any): SettingsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["runMode"] = this.runMode;
        if (this.cardanoChainsNativeTokens) {
            data["cardanoChainsNativeTokens"] = {};
            for (let key in this.cardanoChainsNativeTokens) {
                if (this.cardanoChainsNativeTokens.hasOwnProperty(key))
                    data["cardanoChainsNativeTokens"][key] = this.cardanoChainsNativeTokens[key];
            }
        }
        data["bridgingSettings"] = this.bridgingSettings ? this.bridgingSettings.toJSON() : <any>undefined;
        if (Array.isArray(this.enabledChains)) {
            data["enabledChains"] = [];
            for (let item of this.enabledChains)
                data["enabledChains"].push(item);
        }
        return data; 
    }
}

export interface ISettingsResponseDto {
    /** Specifies the current operating mode of the application */
    runMode: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains: string[];
}

/** Destination chain ID */
export enum ChainEnum {
    Prime = "prime",
    Vector = "vector",
    Nexus = "nexus",
    Cardano = "cardano",
}

export class CreateTransactionDto implements ICreateTransactionDto {
    /** Address that initiates the bridging request on the source chain */
    senderAddress!: string;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    /** Receiver address on destination chain */
    destinationAddress!: string;
    /** Amount to be bridged */
    amount!: string;
    /** Fee covering the submission of the transaction on the destination chain, expressed in Lovelace */
    bridgingFee?: string | undefined;
    /** Fee covering the operational cost of processing the bridging request, expressed in Lovelace */
    operationFee?: string | undefined;
    /** Key used to enable caching of spent UTXOs */
    utxoCacheKey?: string | undefined;
    /** True if the amount is specified in a native token; false if in a currency on source chain */
    isNativeToken!: boolean;

    constructor(data?: ICreateTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderAddress = _data["senderAddress"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.destinationAddress = _data["destinationAddress"];
            this.amount = _data["amount"];
            this.bridgingFee = _data["bridgingFee"];
            this.operationFee = _data["operationFee"];
            this.utxoCacheKey = _data["utxoCacheKey"];
            this.isNativeToken = _data["isNativeToken"];
        }
    }

    static fromJS(data: any): CreateTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderAddress"] = this.senderAddress;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["destinationAddress"] = this.destinationAddress;
        data["amount"] = this.amount;
        data["bridgingFee"] = this.bridgingFee;
        data["operationFee"] = this.operationFee;
        data["utxoCacheKey"] = this.utxoCacheKey;
        data["isNativeToken"] = this.isNativeToken;
        return data; 
    }
}

export interface ICreateTransactionDto {
    /** Address that initiates the bridging request on the source chain */
    senderAddress: string;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    /** Receiver address on destination chain */
    destinationAddress: string;
    /** Amount to be bridged */
    amount: string;
    /** Fee covering the submission of the transaction on the destination chain, expressed in Lovelace */
    bridgingFee?: string | undefined;
    /** Fee covering the operational cost of processing the bridging request, expressed in Lovelace */
    operationFee?: string | undefined;
    /** Key used to enable caching of spent UTXOs */
    utxoCacheKey?: string | undefined;
    /** True if the amount is specified in a native token; false if in a currency on source chain */
    isNativeToken: boolean;
}

export class CreateCardanoTransactionResponseDto implements ICreateCardanoTransactionResponseDto {
    /** Raw transaction data, encoded as a hexadecimal string */
    txRaw!: string;
    /** Transaction hash */
    txHash!: string;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee!: number;
    /** Indicates is fallback mechanism used */
    isFallback!: boolean;
    /** Amount of currency to be bridged, expressed in Lovelace */
    amount!: number;
    /** Amount of native token to be bridged */
    nativeTokenAmount?: number | undefined;

    constructor(data?: ICreateCardanoTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.txRaw = _data["txRaw"];
            this.txHash = _data["txHash"];
            this.bridgingFee = _data["bridgingFee"];
            this.isFallback = _data["isFallback"];
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
        }
    }

    static fromJS(data: any): CreateCardanoTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCardanoTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["txRaw"] = this.txRaw;
        data["txHash"] = this.txHash;
        data["bridgingFee"] = this.bridgingFee;
        data["isFallback"] = this.isFallback;
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        return data; 
    }
}

export interface ICreateCardanoTransactionResponseDto {
    /** Raw transaction data, encoded as a hexadecimal string */
    txRaw: string;
    /** Transaction hash */
    txHash: string;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee: number;
    /** Indicates is fallback mechanism used */
    isFallback: boolean;
    /** Amount of currency to be bridged, expressed in Lovelace */
    amount: number;
    /** Amount of native token to be bridged */
    nativeTokenAmount?: number | undefined;
}

export class CardanoTransactionFeeResponseDto implements ICardanoTransactionFeeResponseDto {
    /** Transaction fee on the source chain, expressed in Lovelace */
    fee!: number;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee!: number;

    constructor(data?: ICardanoTransactionFeeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fee = _data["fee"];
            this.bridgingFee = _data["bridgingFee"];
        }
    }

    static fromJS(data: any): CardanoTransactionFeeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardanoTransactionFeeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fee"] = this.fee;
        data["bridgingFee"] = this.bridgingFee;
        return data; 
    }
}

export interface ICardanoTransactionFeeResponseDto {
    /** Transaction fee on the source chain, expressed in Lovelace */
    fee: number;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee: number;
}

export class CreateEthTransactionResponseDto implements ICreateEthTransactionResponseDto {
    from!: string;
    to!: string;
    value?: string | undefined;
    data!: string;
    bridgingFee!: string;
    isFallback!: boolean;

    constructor(data?: ICreateEthTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.from = _data["from"];
            this.to = _data["to"];
            this.value = _data["value"];
            this.data = _data["data"];
            this.bridgingFee = _data["bridgingFee"];
            this.isFallback = _data["isFallback"];
        }
    }

    static fromJS(data: any): CreateEthTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEthTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["from"] = this.from;
        data["to"] = this.to;
        data["value"] = this.value;
        data["data"] = this.data;
        data["bridgingFee"] = this.bridgingFee;
        data["isFallback"] = this.isFallback;
        return data; 
    }
}

export interface ICreateEthTransactionResponseDto {
    from: string;
    to: string;
    value?: string | undefined;
    data: string;
    bridgingFee: string;
    isFallback: boolean;
}

export class TransactionSubmittedDto implements ITransactionSubmittedDto {
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    /** Transaction hash on source chain */
    originTxHash!: string;
    /** Address that initiated the bridging request on the source chain */
    senderAddress!: string;
    /** Recipient addresses on the destination chain */
    receiverAddrs!: string[];
    /** Amount of currency to be bridged, including bridging fee */
    amount!: string;
    /** Amount of native token to be bridged */
    nativeTokenAmount!: string;
    /** Transaction raw data on source chain */
    txRaw!: string;
    /** Indicates is fallback mechanism used */
    isFallback!: boolean;

    constructor(data?: ITransactionSubmittedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receiverAddrs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.originTxHash = _data["originTxHash"];
            this.senderAddress = _data["senderAddress"];
            if (Array.isArray(_data["receiverAddrs"])) {
                this.receiverAddrs = [] as any;
                for (let item of _data["receiverAddrs"])
                    this.receiverAddrs!.push(item);
            }
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
            this.txRaw = _data["txRaw"];
            this.isFallback = _data["isFallback"];
        }
    }

    static fromJS(data: any): TransactionSubmittedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionSubmittedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["originTxHash"] = this.originTxHash;
        data["senderAddress"] = this.senderAddress;
        if (Array.isArray(this.receiverAddrs)) {
            data["receiverAddrs"] = [];
            for (let item of this.receiverAddrs)
                data["receiverAddrs"].push(item);
        }
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        data["txRaw"] = this.txRaw;
        data["isFallback"] = this.isFallback;
        return data; 
    }
}

export interface ITransactionSubmittedDto {
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    /** Transaction hash on source chain */
    originTxHash: string;
    /** Address that initiated the bridging request on the source chain */
    senderAddress: string;
    /** Recipient addresses on the destination chain */
    receiverAddrs: string[];
    /** Amount of currency to be bridged, including bridging fee */
    amount: string;
    /** Amount of native token to be bridged */
    nativeTokenAmount: string;
    /** Transaction raw data on source chain */
    txRaw: string;
    /** Indicates is fallback mechanism used */
    isFallback: boolean;
}

/** Status of bridging request */
export enum TransactionStatusEnum {
    Pending = "Pending",
    DiscoveredOnSource = "DiscoveredOnSource",
    InvalidRequest = "InvalidRequest",
    SubmittedToBridge = "SubmittedToBridge",
    IncludedInBatch = "IncludedInBatch",
    SubmittedToDestination = "SubmittedToDestination",
    FailedToExecuteOnDestination = "FailedToExecuteOnDestination",
    ExecutedOnDestination = "ExecutedOnDestination",
}

export class BridgeTransactionDto implements IBridgeTransactionDto {
    /** Bridging transaction ID */
    id!: number;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress!: string;
    /** Recipient addresses on the destination chain */
    receiverAddresses!: string;
    /** Bridged amount */
    amount!: string;
    /** Bridged native token amount */
    nativeTokenAmount!: string;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    /** Transaction hash on source chain */
    sourceTxHash!: string;
    /** Transaction hash on destination chain */
    destinationTxHash?: string | undefined;
    status!: TransactionStatusEnum;
    /** Transaction creation date */
    createdAt!: Date;
    /** Transaction finalization date */
    finishedAt?: Date | undefined;

    constructor(data?: IBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.senderAddress = _data["senderAddress"];
            this.receiverAddresses = _data["receiverAddresses"];
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.sourceTxHash = _data["sourceTxHash"];
            this.destinationTxHash = _data["destinationTxHash"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["senderAddress"] = this.senderAddress;
        data["receiverAddresses"] = this.receiverAddresses;
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["sourceTxHash"] = this.sourceTxHash;
        data["destinationTxHash"] = this.destinationTxHash;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBridgeTransactionDto {
    /** Bridging transaction ID */
    id: number;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress: string;
    /** Recipient addresses on the destination chain */
    receiverAddresses: string;
    /** Bridged amount */
    amount: string;
    /** Bridged native token amount */
    nativeTokenAmount: string;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    /** Transaction hash on source chain */
    sourceTxHash: string;
    /** Transaction hash on destination chain */
    destinationTxHash?: string | undefined;
    status: TransactionStatusEnum;
    /** Transaction creation date */
    createdAt: Date;
    /** Transaction finalization date */
    finishedAt?: Date | undefined;
}

export class BridgeTransactionFilterDto implements IBridgeTransactionFilterDto {
    /** Page number to retrieve */
    page?: number | undefined;
    /** Number of items per page */
    perPage?: number | undefined;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress!: string;
    originChain!: ChainEnum;
    destinationChain?: ChainEnum | undefined;
    /** Minimum amount of currency */
    amountFrom?: string | undefined;
    /** Maximum amount of currency */
    amountTo?: string | undefined;
    /** Minimum amount of native token */
    nativeTokenAmountFrom?: string | undefined;
    /** Maximum amount of native token */
    nativeTokenAmountTo?: string | undefined;
    /** Field by which the results should be sorted */
    orderBy?: string | undefined;
    /** Sort direction */
    order?: string | undefined;
    /** Receiver address on destination chain */
    receiverAddress?: string | undefined;

    constructor(data?: IBridgeTransactionFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.senderAddress = _data["senderAddress"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.nativeTokenAmountFrom = _data["nativeTokenAmountFrom"];
            this.nativeTokenAmountTo = _data["nativeTokenAmountTo"];
            this.orderBy = _data["orderBy"];
            this.order = _data["order"];
            this.receiverAddress = _data["receiverAddress"];
        }
    }

    static fromJS(data: any): BridgeTransactionFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["senderAddress"] = this.senderAddress;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["nativeTokenAmountFrom"] = this.nativeTokenAmountFrom;
        data["nativeTokenAmountTo"] = this.nativeTokenAmountTo;
        data["orderBy"] = this.orderBy;
        data["order"] = this.order;
        data["receiverAddress"] = this.receiverAddress;
        return data; 
    }
}

export interface IBridgeTransactionFilterDto {
    /** Page number to retrieve */
    page?: number | undefined;
    /** Number of items per page */
    perPage?: number | undefined;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress: string;
    originChain: ChainEnum;
    destinationChain?: ChainEnum | undefined;
    /** Minimum amount of currency */
    amountFrom?: string | undefined;
    /** Maximum amount of currency */
    amountTo?: string | undefined;
    /** Minimum amount of native token */
    nativeTokenAmountFrom?: string | undefined;
    /** Maximum amount of native token */
    nativeTokenAmountTo?: string | undefined;
    /** Field by which the results should be sorted */
    orderBy?: string | undefined;
    /** Sort direction */
    order?: string | undefined;
    /** Receiver address on destination chain */
    receiverAddress?: string | undefined;
}

export class BridgeTransactionResponseDto implements IBridgeTransactionResponseDto {
    /** Array of bridging transactions */
    items!: BridgeTransactionDto[];
    /** Current page number */
    page!: number;
    /** Number of items returned per page */
    perPage!: number;
    /** Total number of items */
    total!: number;

    constructor(data?: IBridgeTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BridgeTransactionDto.fromJS(item));
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): BridgeTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["total"] = this.total;
        return data; 
    }
}

export interface IBridgeTransactionResponseDto {
    /** Array of bridging transactions */
    items: BridgeTransactionDto[];
    /** Current page number */
    page: number;
    /** Number of items returned per page */
    perPage: number;
    /** Total number of items */
    total: number;
}

export class CreateContactDto implements ICreateContactDto {
    /** Full name of the user submitting the message */
    name!: string;
    /** Email address of the user submitting the message */
    email!: string;
    /** Message to be submitted */
    message!: string;

    constructor(data?: ICreateContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.email = _data["email"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["email"] = this.email;
        data["message"] = this.message;
        return data; 
    }
}

export interface ICreateContactDto {
    /** Full name of the user submitting the message */
    name: string;
    /** Email address of the user submitting the message */
    email: string;
    /** Message to be submitted */
    message: string;
}

export class LockedTokensDto implements ILockedTokensDto {
    /** Mapping of chains to their locked tokens by token type */
    chains!: { [key: string]: { [key: string]: number; }; };
    /** Mapping of total transfered tokens per chain */
    totalTransfered!: { [key: string]: { [key: string]: number; }; };

    constructor(data?: ILockedTokensDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.chains = {};
            this.totalTransfered = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["chains"]) {
                this.chains = {} as any;
                for (let key in _data["chains"]) {
                    if (_data["chains"].hasOwnProperty(key))
                        this.chains![key] = _data["chains"][key] !== undefined ? _data["chains"][key] : {};
                }
            }
            if (_data["totalTransfered"]) {
                this.totalTransfered = {} as any;
                for (let key in _data["totalTransfered"]) {
                    if (_data["totalTransfered"].hasOwnProperty(key))
                        this.totalTransfered![key] = _data["totalTransfered"][key] !== undefined ? _data["totalTransfered"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): LockedTokensDto {
        data = typeof data === 'object' ? data : {};
        let result = new LockedTokensDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.chains) {
            data["chains"] = {};
            for (let key in this.chains) {
                if (this.chains.hasOwnProperty(key))
                    data["chains"][key] = this.chains[key];
            }
        }
        if (this.totalTransfered) {
            data["totalTransfered"] = {};
            for (let key in this.totalTransfered) {
                if (this.totalTransfered.hasOwnProperty(key))
                    data["totalTransfered"][key] = this.totalTransfered[key];
            }
        }
        return data; 
    }
}

export interface ILockedTokensDto {
    /** Mapping of chains to their locked tokens by token type */
    chains: { [key: string]: { [key: string]: number; }; };
    /** Mapping of total transfered tokens per chain */
    totalTransfered: { [key: string]: { [key: string]: number; }; };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}