/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.9.0 (NJsonSchema v10.4.1.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { BaseClient } from './BaseClient';

export class TransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    createBridgingTransaction(body: CreateTransactionDto): Promise<string> {
        let url_ = this.baseUrl + "/transaction/createBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateBridgingTransaction(_response);
        });
    }

    protected processCreateBridgingTransaction(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    signBridgingTransaction(body: SignTransactionDto): Promise<string> {
        let url_ = this.baseUrl + "/transaction/signBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSignBridgingTransaction(_response);
        });
    }

    protected processSignBridgingTransaction(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }

    /**
     * @return Success
     */
    submitBridgingTransaction(body: SubmitTransactionDto): Promise<string> {
        let url_ = this.baseUrl + "/transaction/submitBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSubmitBridgingTransaction(_response);
        });
    }

    protected processSubmitBridgingTransaction(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export class AuthControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    generateLoginCode(body: GenerateLoginCodeDto): Promise<LoginCodeDto> {
        let url_ = this.baseUrl + "/auth/generateLoginCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateLoginCode(_response);
        });
    }

    protected processGenerateLoginCode(response: Response): Promise<LoginCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginCodeDto>(<any>null);
    }

    /**
     * @return Success
     */
    login(body: LoginDto): Promise<TokenDto> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(<any>null);
    }
}

export class BridgeTransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAll(): Promise<BridgeTransactionDto[]> {
        let url_ = this.baseUrl + "/bridgeTransaction";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<BridgeTransactionDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BridgeTransactionDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    create(body: CreateBridgeTransactionDto): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(<any>null);
    }

    /**
     * @return Success
     */
    update(body: UpdateBridgeTransactionDto): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(<any>null);
    }

    /**
     * @return Success
     */
    getAllFiltered(body: BridgeTransactionFilterDto): Promise<BridgeTransactionResponseDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllFiltered(_response);
        });
    }

    protected processGetAllFiltered(response: Response): Promise<BridgeTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionResponseDto>(<any>null);
    }
}

export enum ChainEnum {
    Prime = "Prime",
    Vector = "Vector",
}

export class CreateTransactionDto implements ICreateTransactionDto {
    senderAddress!: string;
    receiverAddress!: string;
    amount!: number;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;

    constructor(data?: ICreateTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderAddress = _data["senderAddress"];
            this.receiverAddress = _data["receiverAddress"];
            this.amount = _data["amount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
        }
    }

    static fromJS(data: any): CreateTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderAddress"] = this.senderAddress;
        data["receiverAddress"] = this.receiverAddress;
        data["amount"] = this.amount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        return data; 
    }
}

export interface ICreateTransactionDto {
    senderAddress: string;
    receiverAddress: string;
    amount: number;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
}

export class SignTransactionDto implements ISignTransactionDto {
    privateKey!: string;
    transaction!: string;

    constructor(data?: ISignTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.privateKey = _data["privateKey"];
            this.transaction = _data["transaction"];
        }
    }

    static fromJS(data: any): SignTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["privateKey"] = this.privateKey;
        data["transaction"] = this.transaction;
        return data; 
    }
}

export interface ISignTransactionDto {
    privateKey: string;
    transaction: string;
}

export class SubmitTransactionDto implements ISubmitTransactionDto {
    chain!: ChainEnum;
    transaction!: string;

    constructor(data?: ISubmitTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.chain = _data["chain"];
            this.transaction = _data["transaction"];
        }
    }

    static fromJS(data: any): SubmitTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chain"] = this.chain;
        data["transaction"] = this.transaction;
        return data; 
    }
}

export interface ISubmitTransactionDto {
    chain: ChainEnum;
    transaction: string;
}

export class GenerateLoginCodeDto implements IGenerateLoginCodeDto {
    address!: string;

    constructor(data?: IGenerateLoginCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): GenerateLoginCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateLoginCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        return data; 
    }
}

export interface IGenerateLoginCodeDto {
    address: string;
}

export class LoginCodeDto implements ILoginCodeDto {
    address!: string;
    code!: string;

    constructor(data?: ILoginCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): LoginCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["code"] = this.code;
        return data; 
    }
}

export interface ILoginCodeDto {
    address: string;
    code: string;
}

export class DataSignatureDto implements IDataSignatureDto {
    signature!: string;
    key!: string;

    constructor(data?: IDataSignatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signature = _data["signature"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): DataSignatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSignatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signature"] = this.signature;
        data["key"] = this.key;
        return data; 
    }
}

export interface IDataSignatureDto {
    signature: string;
    key: string;
}

export class LoginDto implements ILoginDto {
    address!: string;
    signedLoginCode!: DataSignatureDto;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.signedLoginCode = new DataSignatureDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.signedLoginCode = _data["signedLoginCode"] ? DataSignatureDto.fromJS(_data["signedLoginCode"]) : new DataSignatureDto();
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["signedLoginCode"] = this.signedLoginCode ? this.signedLoginCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoginDto {
    address: string;
    signedLoginCode: DataSignatureDto;
}

export class TokenDto implements ITokenDto {
    address!: string;
    token!: string;
    expiresAt!: Date;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.token = _data["token"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["token"] = this.token;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITokenDto {
    address: string;
    token: string;
    expiresAt: Date;
}

export enum TransactionStatusEnum {
    Pending = "Pending",
    Success = "Success",
    Failed = "Failed",
}

export class BridgeTransactionDto implements IBridgeTransactionDto {
    id!: number;
    senderAddress!: string;
    receiverAddress!: string;
    amount!: number;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    status!: TransactionStatusEnum;
    createdAt!: Date;
    finishedAt?: Date | undefined;

    constructor(data?: IBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.senderAddress = _data["senderAddress"];
            this.receiverAddress = _data["receiverAddress"];
            this.amount = _data["amount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["senderAddress"] = this.senderAddress;
        data["receiverAddress"] = this.receiverAddress;
        data["amount"] = this.amount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IBridgeTransactionDto {
    id: number;
    senderAddress: string;
    receiverAddress: string;
    amount: number;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    status: TransactionStatusEnum;
    createdAt: Date;
    finishedAt?: Date | undefined;
}

export class BridgeTransactionFilterDto implements IBridgeTransactionFilterDto {
    page?: number | undefined;
    perPage?: number | undefined;
    destinationChain?: TransactionStatusEnum | undefined;
    receiverAddress?: string | undefined;
    amountFrom?: number | undefined;
    amountTo?: number | undefined;
    orderBy?: string | undefined;
    order?: string | undefined;

    constructor(data?: IBridgeTransactionFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.destinationChain = _data["destinationChain"];
            this.receiverAddress = _data["receiverAddress"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.orderBy = _data["orderBy"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): BridgeTransactionFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["destinationChain"] = this.destinationChain;
        data["receiverAddress"] = this.receiverAddress;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["orderBy"] = this.orderBy;
        data["order"] = this.order;
        return data; 
    }
}

export interface IBridgeTransactionFilterDto {
    page?: number | undefined;
    perPage?: number | undefined;
    destinationChain?: TransactionStatusEnum | undefined;
    receiverAddress?: string | undefined;
    amountFrom?: number | undefined;
    amountTo?: number | undefined;
    orderBy?: string | undefined;
    order?: string | undefined;
}

export class BridgeTransactionResponseDto implements IBridgeTransactionResponseDto {
    items!: BridgeTransactionDto[];
    page!: number;
    perPage!: number;
    total!: number;

    constructor(data?: IBridgeTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BridgeTransactionDto.fromJS(item));
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): BridgeTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["total"] = this.total;
        return data; 
    }
}

export interface IBridgeTransactionResponseDto {
    items: BridgeTransactionDto[];
    page: number;
    perPage: number;
    total: number;
}

export class CreateBridgeTransactionDto implements ICreateBridgeTransactionDto {
    senderAddress!: string;
    receiverAddress!: string;
    amount!: number;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;

    constructor(data?: ICreateBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.senderAddress = _data["senderAddress"];
            this.receiverAddress = _data["receiverAddress"];
            this.amount = _data["amount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
        }
    }

    static fromJS(data: any): CreateBridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderAddress"] = this.senderAddress;
        data["receiverAddress"] = this.receiverAddress;
        data["amount"] = this.amount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        return data; 
    }
}

export interface ICreateBridgeTransactionDto {
    senderAddress: string;
    receiverAddress: string;
    amount: number;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
}

export class UpdateBridgeTransactionDto implements IUpdateBridgeTransactionDto {
    id!: number;
    status!: TransactionStatusEnum;

    constructor(data?: IUpdateBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UpdateBridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateBridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        return data; 
    }
}

export interface IUpdateBridgeTransactionDto {
    id: number;
    status: TransactionStatusEnum;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}