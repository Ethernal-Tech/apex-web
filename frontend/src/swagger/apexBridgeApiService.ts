//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { BaseClient } from './BaseClient';

export class TransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    createBridgingTransaction(body: CreateTransactionDto): Promise<CreateTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/createBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateBridgingTransaction(_response);
        });
    }

    protected processCreateBridgingTransaction(response: Response): Promise<CreateTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateTransactionResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    signBridgingTransaction(body: SignTransactionDto): Promise<TransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/signBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSignBridgingTransaction(_response);
        });
    }

    protected processSignBridgingTransaction(response: Response): Promise<TransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TransactionResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    submitBridgingTransaction(body: SubmitTransactionDto): Promise<SubmitTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/submitBridgingTransaction";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSubmitBridgingTransaction(_response);
        });
    }

    protected processSubmitBridgingTransaction(response: Response): Promise<SubmitTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubmitTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubmitTransactionResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    bridgingTransactionSubmitted(body: TransactionSubmittedDto): Promise<void> {
        let url_ = this.baseUrl + "/transaction/bridgingTransactionSubmitted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBridgingTransactionSubmitted(_response);
        });
    }

    protected processBridgingTransactionSubmitted(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class AuthControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    generateLoginCode(body: GenerateLoginCodeDto): Promise<LoginCodeDto> {
        let url_ = this.baseUrl + "/auth/generateLoginCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGenerateLoginCode(_response);
        });
    }

    protected processGenerateLoginCode(response: Response): Promise<LoginCodeDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginCodeDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginCodeDto>(null as any);
    }

    /**
     * @return Success
     */
    login(body: LoginDto): Promise<TokenDto> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<TokenDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TokenDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TokenDto>(null as any);
    }
}

export class BridgeTransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * @return Success
     */
    get(id: number): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(null as any);
    }

    /**
     * @return Success
     */
    getAllFiltered(body: BridgeTransactionFilterDto): Promise<BridgeTransactionResponseDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllFiltered(_response);
        });
    }

    protected processGetAllFiltered(response: Response): Promise<BridgeTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionResponseDto>(null as any);
    }
}

export enum ChainEnum {
    Prime = "prime",
    Vector = "vector",
}

export class CreateTransactionReceiverDto implements ICreateTransactionReceiverDto {
    address!: string;
    amount!: number;

    [key: string]: any;

    constructor(data?: ICreateTransactionReceiverDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.address = _data["address"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): CreateTransactionReceiverDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionReceiverDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["address"] = this.address;
        data["amount"] = this.amount;
        return data;
    }
}

export interface ICreateTransactionReceiverDto {
    address: string;
    amount: number;

    [key: string]: any;
}

export class CreateTransactionDto implements ICreateTransactionDto {
    destinationChain!: ChainEnum;
    receivers!: CreateTransactionReceiverDto[];
    bridgingFee!: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receivers = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.destinationChain = _data["destinationChain"];
            if (Array.isArray(_data["receivers"])) {
                this.receivers = [] as any;
                for (let item of _data["receivers"])
                    this.receivers!.push(CreateTransactionReceiverDto.fromJS(item));
            }
            this.bridgingFee = _data["bridgingFee"];
        }
    }

    static fromJS(data: any): CreateTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["destinationChain"] = this.destinationChain;
        if (Array.isArray(this.receivers)) {
            data["receivers"] = [];
            for (let item of this.receivers)
                data["receivers"].push(item.toJSON());
        }
        data["bridgingFee"] = this.bridgingFee;
        return data;
    }
}

export interface ICreateTransactionDto {
    destinationChain: ChainEnum;
    receivers: CreateTransactionReceiverDto[];
    bridgingFee: number | undefined;

    [key: string]: any;
}

export class CreateTransactionResponseDto implements ICreateTransactionResponseDto {
    txRaw!: string;
    txHash!: string;
    bridgingFee!: number;

    [key: string]: any;

    constructor(data?: ICreateTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.txRaw = _data["txRaw"];
            this.txHash = _data["txHash"];
            this.bridgingFee = _data["bridgingFee"];
        }
    }

    static fromJS(data: any): CreateTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["txRaw"] = this.txRaw;
        data["txHash"] = this.txHash;
        data["bridgingFee"] = this.bridgingFee;
        return data;
    }
}

export interface ICreateTransactionResponseDto {
    txRaw: string;
    txHash: string;
    bridgingFee: number;

    [key: string]: any;
}

export class SignTransactionDto implements ISignTransactionDto {
    signingKeyHex!: string;
    txRaw!: string;
    txHash!: string;

    [key: string]: any;

    constructor(data?: ISignTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.signingKeyHex = _data["signingKeyHex"];
            this.txRaw = _data["txRaw"];
            this.txHash = _data["txHash"];
        }
    }

    static fromJS(data: any): SignTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SignTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["signingKeyHex"] = this.signingKeyHex;
        data["txRaw"] = this.txRaw;
        data["txHash"] = this.txHash;
        return data;
    }
}

export interface ISignTransactionDto {
    signingKeyHex: string;
    txRaw: string;
    txHash: string;

    [key: string]: any;
}

export class TransactionResponseDto implements ITransactionResponseDto {
    txRaw!: string;
    txHash!: string;

    [key: string]: any;

    constructor(data?: ITransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.txRaw = _data["txRaw"];
            this.txHash = _data["txHash"];
        }
    }

    static fromJS(data: any): TransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["txRaw"] = this.txRaw;
        data["txHash"] = this.txHash;
        return data;
    }
}

export interface ITransactionResponseDto {
    txRaw: string;
    txHash: string;

    [key: string]: any;
}

export class SubmitTransactionDto implements ISubmitTransactionDto {
    destinationChain!: ChainEnum;
    originTxHash!: string;
    receiverAddrs!: string[];
    amount!: number;
    signedTxRaw!: string;

    [key: string]: any;

    constructor(data?: ISubmitTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receiverAddrs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.destinationChain = _data["destinationChain"];
            this.originTxHash = _data["originTxHash"];
            if (Array.isArray(_data["receiverAddrs"])) {
                this.receiverAddrs = [] as any;
                for (let item of _data["receiverAddrs"])
                    this.receiverAddrs!.push(item);
            }
            this.amount = _data["amount"];
            this.signedTxRaw = _data["signedTxRaw"];
        }
    }

    static fromJS(data: any): SubmitTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["destinationChain"] = this.destinationChain;
        data["originTxHash"] = this.originTxHash;
        if (Array.isArray(this.receiverAddrs)) {
            data["receiverAddrs"] = [];
            for (let item of this.receiverAddrs)
                data["receiverAddrs"].push(item);
        }
        data["amount"] = this.amount;
        data["signedTxRaw"] = this.signedTxRaw;
        return data;
    }
}

export interface ISubmitTransactionDto {
    destinationChain: ChainEnum;
    originTxHash: string;
    receiverAddrs: string[];
    amount: number;
    signedTxRaw: string;

    [key: string]: any;
}

export class SubmitTransactionResponseDto implements ISubmitTransactionResponseDto {
    txId!: string;

    [key: string]: any;

    constructor(data?: ISubmitTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.txId = _data["txId"];
        }
    }

    static fromJS(data: any): SubmitTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubmitTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["txId"] = this.txId;
        return data;
    }
}

export interface ISubmitTransactionResponseDto {
    txId: string;

    [key: string]: any;
}

export class TransactionSubmittedDto implements ITransactionSubmittedDto {
    destinationChain!: ChainEnum;
    originTxHash!: string;
    receiverAddrs!: string[];
    amount!: number;

    [key: string]: any;

    constructor(data?: ITransactionSubmittedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.receiverAddrs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.destinationChain = _data["destinationChain"];
            this.originTxHash = _data["originTxHash"];
            if (Array.isArray(_data["receiverAddrs"])) {
                this.receiverAddrs = [] as any;
                for (let item of _data["receiverAddrs"])
                    this.receiverAddrs!.push(item);
            }
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): TransactionSubmittedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionSubmittedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["destinationChain"] = this.destinationChain;
        data["originTxHash"] = this.originTxHash;
        if (Array.isArray(this.receiverAddrs)) {
            data["receiverAddrs"] = [];
            for (let item of this.receiverAddrs)
                data["receiverAddrs"].push(item);
        }
        data["amount"] = this.amount;
        return data;
    }
}

export interface ITransactionSubmittedDto {
    destinationChain: ChainEnum;
    originTxHash: string;
    receiverAddrs: string[];
    amount: number;

    [key: string]: any;
}

export class GenerateLoginCodeDto implements IGenerateLoginCodeDto {
    address!: string;
    chainId!: ChainEnum;

    [key: string]: any;

    constructor(data?: IGenerateLoginCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.address = _data["address"];
            this.chainId = _data["chainId"];
        }
    }

    static fromJS(data: any): GenerateLoginCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateLoginCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["address"] = this.address;
        data["chainId"] = this.chainId;
        return data;
    }
}

export interface IGenerateLoginCodeDto {
    address: string;
    chainId: ChainEnum;

    [key: string]: any;
}

export class LoginCodeDto implements ILoginCodeDto {
    address!: string;
    code!: string;
    chainId!: ChainEnum;

    [key: string]: any;

    constructor(data?: ILoginCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.address = _data["address"];
            this.code = _data["code"];
            this.chainId = _data["chainId"];
        }
    }

    static fromJS(data: any): LoginCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["address"] = this.address;
        data["code"] = this.code;
        data["chainId"] = this.chainId;
        return data;
    }
}

export interface ILoginCodeDto {
    address: string;
    code: string;
    chainId: ChainEnum;

    [key: string]: any;
}

export class DataSignatureDto implements IDataSignatureDto {
    signature!: string;
    key!: string;

    [key: string]: any;

    constructor(data?: IDataSignatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.signature = _data["signature"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): DataSignatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataSignatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["signature"] = this.signature;
        data["key"] = this.key;
        return data;
    }
}

export interface IDataSignatureDto {
    signature: string;
    key: string;

    [key: string]: any;
}

export class LoginDto implements ILoginDto {
    address!: string;
    signedLoginCode!: DataSignatureDto;
    chainId!: ChainEnum;

    [key: string]: any;

    constructor(data?: ILoginDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.signedLoginCode = new DataSignatureDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.address = _data["address"];
            this.signedLoginCode = _data["signedLoginCode"] ? DataSignatureDto.fromJS(_data["signedLoginCode"]) : new DataSignatureDto();
            this.chainId = _data["chainId"];
        }
    }

    static fromJS(data: any): LoginDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["address"] = this.address;
        data["signedLoginCode"] = this.signedLoginCode ? this.signedLoginCode.toJSON() : <any>undefined;
        data["chainId"] = this.chainId;
        return data;
    }
}

export interface ILoginDto {
    address: string;
    signedLoginCode: DataSignatureDto;
    chainId: ChainEnum;

    [key: string]: any;
}

export class TokenDto implements ITokenDto {
    address!: string;
    token!: string;
    expiresAt!: Date;
    chainId!: ChainEnum;

    [key: string]: any;

    constructor(data?: ITokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.address = _data["address"];
            this.token = _data["token"];
            this.expiresAt = _data["expiresAt"] ? new Date(_data["expiresAt"].toString()) : <any>undefined;
            this.chainId = _data["chainId"];
        }
    }

    static fromJS(data: any): TokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new TokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["address"] = this.address;
        data["token"] = this.token;
        data["expiresAt"] = this.expiresAt ? this.expiresAt.toISOString() : <any>undefined;
        data["chainId"] = this.chainId;
        return data;
    }
}

export interface ITokenDto {
    address: string;
    token: string;
    expiresAt: Date;
    chainId: ChainEnum;

    [key: string]: any;
}

export enum TransactionStatusEnum {
    Pending = "Pending",
    DiscoveredOnSource = "DiscoveredOnSource",
    InvalidRequest = "InvalidRequest",
    SubmittedToBridge = "SubmittedToBridge",
    IncludedInBatch = "IncludedInBatch",
    SubmittedToDestination = "SubmittedToDestination",
    FailedToExecuteOnDestination = "FailedToExecuteOnDestination",
    ExecutedOnDestination = "ExecutedOnDestination",
}

export class BridgeTransactionDto implements IBridgeTransactionDto {
    id!: number;
    senderAddress!: string;
    receiverAddresses!: string;
    amount!: number;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    status!: TransactionStatusEnum;
    createdAt!: Date;
    finishedAt?: Date | undefined;

    [key: string]: any;

    constructor(data?: IBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.senderAddress = _data["senderAddress"];
            this.receiverAddresses = _data["receiverAddresses"];
            this.amount = _data["amount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["senderAddress"] = this.senderAddress;
        data["receiverAddresses"] = this.receiverAddresses;
        data["amount"] = this.amount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBridgeTransactionDto {
    id: number;
    senderAddress: string;
    receiverAddresses: string;
    amount: number;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    status: TransactionStatusEnum;
    createdAt: Date;
    finishedAt?: Date | undefined;

    [key: string]: any;
}

export class BridgeTransactionFilterDto implements IBridgeTransactionFilterDto {
    page?: number | undefined;
    perPage?: number | undefined;
    destinationChain?: ChainEnum | undefined;
    amountFrom?: number | undefined;
    amountTo?: number | undefined;
    orderBy?: string | undefined;
    order?: string | undefined;

    [key: string]: any;

    constructor(data?: IBridgeTransactionFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.destinationChain = _data["destinationChain"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.orderBy = _data["orderBy"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): BridgeTransactionFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["destinationChain"] = this.destinationChain;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["orderBy"] = this.orderBy;
        data["order"] = this.order;
        return data;
    }
}

export interface IBridgeTransactionFilterDto {
    page?: number | undefined;
    perPage?: number | undefined;
    destinationChain?: ChainEnum | undefined;
    amountFrom?: number | undefined;
    amountTo?: number | undefined;
    orderBy?: string | undefined;
    order?: string | undefined;

    [key: string]: any;
}

export class BridgeTransactionResponseDto implements IBridgeTransactionResponseDto {
    items!: BridgeTransactionDto[];
    page!: number;
    perPage!: number;
    total!: number;

    [key: string]: any;

    constructor(data?: IBridgeTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BridgeTransactionDto.fromJS(item));
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): BridgeTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["total"] = this.total;
        return data;
    }
}

export interface IBridgeTransactionResponseDto {
    items: BridgeTransactionDto[];
    page: number;
    perPage: number;
    total: number;

    [key: string]: any;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}