//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming
import { BaseClient } from "./BaseClient";

export class SettingsControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get bridge settings
     * @return OK - Returns the configuration settings.
     */
    get(): Promise<SettingsFullResponseDto> {
        let url_ = this.baseUrl + "/settings";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<SettingsFullResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SettingsFullResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SettingsFullResponseDto>(null as any);
    }
}

export class TransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Create a bridging transaction
     * @return OK - Returns the raw transaction data, transaction hash, and calculated bridging fee and amounts.
     */
    createCardano(body: CreateTransactionDto): Promise<CreateCardanoTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/createCardano";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateCardano(_response);
        });
    }

    protected processCreateCardano(response: Response): Promise<CreateCardanoTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateCardanoTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while creating bridging transaction.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateCardanoTransactionResponseDto>(null as any);
    }

    /**
     * Get fees required for a bridging transaction
     * @return OK - Returns calculated fees.
     */
    getCardanoTxFee(body: CreateTransactionDto): Promise<CardanoTransactionFeeResponseDto> {
        let url_ = this.baseUrl + "/transaction/getCardanoTxFee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetCardanoTxFee(_response);
        });
    }

    protected processGetCardanoTxFee(response: Response): Promise<CardanoTransactionFeeResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CardanoTransactionFeeResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while getting bridging transaction fees.", status, _responseText, _headers);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            return throwException("Internal server Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CardanoTransactionFeeResponseDto>(null as any);
    }

    /**
     * @return Success
     */
    createEth(body: CreateTransactionDto): Promise<CreateEthTransactionResponseDto> {
        let url_ = this.baseUrl + "/transaction/createEth";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateEth(_response);
        });
    }

    protected processCreateEth(response: Response): Promise<CreateEthTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateEthTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CreateEthTransactionResponseDto>(null as any);
    }

    /**
     * Confirm the bridging transaction submission on the source chain
     * @return OK - Returns confirmed bridging transaction.
     */
    bridgingTransactionSubmitted(body: TransactionSubmittedDto): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/transaction/bridgingTransactionSubmitted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBridgingTransactionSubmitted(_response);
        });
    }

    protected processBridgingTransactionSubmitted(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error while confirming transaction submittion.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(null as any);
    }

    /**
     * Layer Zero transfer proxy call
     * @return OK - Returns data recieved from Layer Zero API.
     */
    layerZeroTransfer(body: LayerZeroTransferDto): Promise<LayerZeroTransferResponseDto> {
        let url_ = this.baseUrl + "/transaction/layerZeroTransfer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLayerZeroTransfer(_response);
        });
    }

    protected processLayerZeroTransfer(response: Response): Promise<LayerZeroTransferResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LayerZeroTransferResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            return throwException("Bad Request - Error", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LayerZeroTransferResponseDto>(null as any);
    }
}

export class BridgeTransactionControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get the bridging transaction details
     * @return OK - Returns bridging transaction.
     */
    get(id: number): Promise<BridgeTransactionDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<BridgeTransactionDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionDto.fromJS(resultData200);
            return result200;
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            return throwException("Not Found - Bridging transaction not found.", status, _responseText, _headers);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionDto>(null as any);
    }

    /**
     * Get multiple bridging transactions with filtering and pagination
     * @return OK - Returns bridging transactions.
     */
    getAllFiltered(body: BridgeTransactionFilterDto): Promise<BridgeTransactionResponseDto> {
        let url_ = this.baseUrl + "/bridgeTransaction/filter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAllFiltered(_response);
        });
    }

    protected processGetAllFiltered(response: Response): Promise<BridgeTransactionResponseDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BridgeTransactionResponseDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BridgeTransactionResponseDto>(null as any);
    }
}

export class ContactControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Submit a contact message
     * @return OK - Message submitted.
     */
    submitContactForm(body: CreateContactDto): Promise<void> {
        let url_ = this.baseUrl + "/contact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSubmitContactForm(_response);
        });
    }

    protected processSubmitContactForm(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }
}

export class LockedTokensControllerClient extends BaseClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : window as any;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    /**
     * Get locked tokens amount
     * @return OK - Get locked tokens amount.
     */
    get(): Promise<LockedTokensDto> {
        let url_ = this.baseUrl + "/lockedTokens";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<LockedTokensDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LockedTokensDto.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LockedTokensDto>(null as any);
    }

    /**
     * Get sum of transferred tokens per chain
     * @param startDate Start date in ISO format (e.g., 2024-01-01)
     * @param endDate End date in ISO format (e.g., 2024-12-31)
     * @param groupBy (optional) Time period to group by: hour, day, week, or month (default is day)
     * @return OK - Returns the sum of transferred tokens per chain.
     */
    getTransferredSum(startDate: string, endDate: string, groupBy: GroupBy | undefined): Promise<LockedTokensResponse> {
        let url_ = this.baseUrl + "/lockedTokens/transferred?";
        if (startDate === undefined || startDate === null)
            throw new globalThis.Error("The parameter 'startDate' must be defined and cannot be null.");
        else
            url_ += "startDate=" + encodeURIComponent("" + startDate) + "&";
        if (endDate === undefined || endDate === null)
            throw new globalThis.Error("The parameter 'endDate' must be defined and cannot be null.");
        else
            url_ += "endDate=" + encodeURIComponent("" + endDate) + "&";
        if (groupBy === null)
            throw new globalThis.Error("The parameter 'groupBy' cannot be null.");
        else if (groupBy !== undefined)
            url_ += "groupBy=" + encodeURIComponent("" + groupBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetTransferredSum(_response);
        });
    }

    protected processGetTransferredSum(response: Response): Promise<LockedTokensResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LockedTokensResponse.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LockedTokensResponse>(null as any);
    }
}

export class NativeTokenDto implements INativeTokenDto {
    /** Destination chain ID */
    dstChainID!: string;
    /** Native token name */
    tokenName!: string;

    [key: string]: any;

    constructor(data?: INativeTokenDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dstChainID = _data["dstChainID"];
            this.tokenName = _data["tokenName"];
        }
    }

    static fromJS(data: any): NativeTokenDto {
        data = typeof data === 'object' ? data : {};
        let result = new NativeTokenDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dstChainID"] = this.dstChainID;
        data["tokenName"] = this.tokenName;
        return data;
    }
}

export interface INativeTokenDto {
    /** Destination chain ID */
    dstChainID: string;
    /** Native token name */
    tokenName: string;

    [key: string]: any;
}

export class BridgingSettingsDto implements IBridgingSettingsDto {
    /** For each chain, the minimum fee required to cover the submission of the transaction on the destination chain */
    minChainFeeForBridging!: { [key: string]: number; };
    /** For each chain, the minimum fee required to cover operational costs */
    minOperationFee!: { [key: string]: number; };
    /** For each chain, the minimum allowed UTXO value */
    minUtxoChainValue!: { [key: string]: number; };
    /** Minimum value allowed to be bridged */
    minValueToBridge!: number;
    /** Maximum amount of currency allowed to be bridged */
    maxAmountAllowedToBridge!: string;
    /** Maximum amount of native tokens allowed to be bridged */
    maxTokenAmountAllowedToBridge!: string;
    /** Maximum number of receivers allowed in a bridging request */
    maxReceiversPerBridgingRequest!: number;

    [key: string]: any;

    constructor(data?: IBridgingSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.minChainFeeForBridging = {};
            this.minOperationFee = {};
            this.minUtxoChainValue = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["minChainFeeForBridging"]) {
                this.minChainFeeForBridging = {} as any;
                for (let key in _data["minChainFeeForBridging"]) {
                    if (_data["minChainFeeForBridging"].hasOwnProperty(key))
                        (this.minChainFeeForBridging as any)![key] = _data["minChainFeeForBridging"][key];
                }
            }
            if (_data["minOperationFee"]) {
                this.minOperationFee = {} as any;
                for (let key in _data["minOperationFee"]) {
                    if (_data["minOperationFee"].hasOwnProperty(key))
                        (this.minOperationFee as any)![key] = _data["minOperationFee"][key];
                }
            }
            if (_data["minUtxoChainValue"]) {
                this.minUtxoChainValue = {} as any;
                for (let key in _data["minUtxoChainValue"]) {
                    if (_data["minUtxoChainValue"].hasOwnProperty(key))
                        (this.minUtxoChainValue as any)![key] = _data["minUtxoChainValue"][key];
                }
            }
            this.minValueToBridge = _data["minValueToBridge"];
            this.maxAmountAllowedToBridge = _data["maxAmountAllowedToBridge"];
            this.maxTokenAmountAllowedToBridge = _data["maxTokenAmountAllowedToBridge"];
            this.maxReceiversPerBridgingRequest = _data["maxReceiversPerBridgingRequest"];
        }
    }

    static fromJS(data: any): BridgingSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgingSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.minChainFeeForBridging) {
            data["minChainFeeForBridging"] = {};
            for (let key in this.minChainFeeForBridging) {
                if (this.minChainFeeForBridging.hasOwnProperty(key))
                    (data["minChainFeeForBridging"] as any)[key] = (this.minChainFeeForBridging as any)[key];
            }
        }
        if (this.minOperationFee) {
            data["minOperationFee"] = {};
            for (let key in this.minOperationFee) {
                if (this.minOperationFee.hasOwnProperty(key))
                    (data["minOperationFee"] as any)[key] = (this.minOperationFee as any)[key];
            }
        }
        if (this.minUtxoChainValue) {
            data["minUtxoChainValue"] = {};
            for (let key in this.minUtxoChainValue) {
                if (this.minUtxoChainValue.hasOwnProperty(key))
                    (data["minUtxoChainValue"] as any)[key] = (this.minUtxoChainValue as any)[key];
            }
        }
        data["minValueToBridge"] = this.minValueToBridge;
        data["maxAmountAllowedToBridge"] = this.maxAmountAllowedToBridge;
        data["maxTokenAmountAllowedToBridge"] = this.maxTokenAmountAllowedToBridge;
        data["maxReceiversPerBridgingRequest"] = this.maxReceiversPerBridgingRequest;
        return data;
    }
}

export interface IBridgingSettingsDto {
    /** For each chain, the minimum fee required to cover the submission of the transaction on the destination chain */
    minChainFeeForBridging: { [key: string]: number; };
    /** For each chain, the minimum fee required to cover operational costs */
    minOperationFee: { [key: string]: number; };
    /** For each chain, the minimum allowed UTXO value */
    minUtxoChainValue: { [key: string]: number; };
    /** Minimum value allowed to be bridged */
    minValueToBridge: number;
    /** Maximum amount of currency allowed to be bridged */
    maxAmountAllowedToBridge: string;
    /** Maximum amount of native tokens allowed to be bridged */
    maxTokenAmountAllowedToBridge: string;
    /** Maximum number of receivers allowed in a bridging request */
    maxReceiversPerBridgingRequest: number;

    [key: string]: any;
}

export class SettingsResponseDto implements ISettingsResponseDto {
    /** Specifies the current operating mode of the application */
    runMode!: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens!: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings!: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains!: string[];

    [key: string]: any;

    constructor(data?: ISettingsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.cardanoChainsNativeTokens = {};
            this.bridgingSettings = new BridgingSettingsDto();
            this.enabledChains = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.runMode = _data["runMode"];
            if (_data["cardanoChainsNativeTokens"]) {
                this.cardanoChainsNativeTokens = {} as any;
                for (let key in _data["cardanoChainsNativeTokens"]) {
                    if (_data["cardanoChainsNativeTokens"].hasOwnProperty(key))
                        (this.cardanoChainsNativeTokens as any)![key] = _data["cardanoChainsNativeTokens"][key] ? _data["cardanoChainsNativeTokens"][key].map((i: any) => NativeTokenDto.fromJS(i)) : [];
                }
            }
            this.bridgingSettings = _data["bridgingSettings"] ? BridgingSettingsDto.fromJS(_data["bridgingSettings"]) : new BridgingSettingsDto();
            if (Array.isArray(_data["enabledChains"])) {
                this.enabledChains = [] as any;
                for (let item of _data["enabledChains"])
                    this.enabledChains!.push(item);
            }
        }
    }

    static fromJS(data: any): SettingsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["runMode"] = this.runMode;
        if (this.cardanoChainsNativeTokens) {
            data["cardanoChainsNativeTokens"] = {};
            for (let key in this.cardanoChainsNativeTokens) {
                if (this.cardanoChainsNativeTokens.hasOwnProperty(key))
                    (data["cardanoChainsNativeTokens"] as any)[key] = (this.cardanoChainsNativeTokens as any)[key];
            }
        }
        data["bridgingSettings"] = this.bridgingSettings ? this.bridgingSettings.toJSON() : undefined as any;
        if (Array.isArray(this.enabledChains)) {
            data["enabledChains"] = [];
            for (let item of this.enabledChains)
                data["enabledChains"].push(item);
        }
        return data;
    }
}

export interface ISettingsResponseDto {
    /** Specifies the current operating mode of the application */
    runMode: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains: string[];

    [key: string]: any;
}

export class LayerZeroChainSettingsDto implements ILayerZeroChainSettingsDto {
    /** Chain name */
    chain!: LayerZeroChainSettingsDtoChain;
    /** Chain RPC url */
    rpcUrl!: string;
    /** Layer Zero OFT smart contract address */
    oftAddress!: string;
    /** EVM chain ID */
    chainID!: number;

    [key: string]: any;

    constructor(data?: ILayerZeroChainSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.chain = _data["chain"];
            this.rpcUrl = _data["rpcUrl"];
            this.oftAddress = _data["oftAddress"];
            this.chainID = _data["chainID"];
        }
    }

    static fromJS(data: any): LayerZeroChainSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayerZeroChainSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["chain"] = this.chain;
        data["rpcUrl"] = this.rpcUrl;
        data["oftAddress"] = this.oftAddress;
        data["chainID"] = this.chainID;
        return data;
    }
}

export interface ILayerZeroChainSettingsDto {
    /** Chain name */
    chain: LayerZeroChainSettingsDtoChain;
    /** Chain RPC url */
    rpcUrl: string;
    /** Layer Zero OFT smart contract address */
    oftAddress: string;
    /** EVM chain ID */
    chainID: number;

    [key: string]: any;
}

export class SettingsFullResponseDto implements ISettingsFullResponseDto {
    /** Specifies the current operating mode of the application */
    runMode!: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens!: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings!: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains!: string[];
    /** LayerZero chains and their configurations */
    layerZeroChains!: LayerZeroChainSettingsDto[];

    [key: string]: any;

    constructor(data?: ISettingsFullResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.cardanoChainsNativeTokens = {};
            this.bridgingSettings = new BridgingSettingsDto();
            this.enabledChains = [];
            this.layerZeroChains = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.runMode = _data["runMode"];
            if (_data["cardanoChainsNativeTokens"]) {
                this.cardanoChainsNativeTokens = {} as any;
                for (let key in _data["cardanoChainsNativeTokens"]) {
                    if (_data["cardanoChainsNativeTokens"].hasOwnProperty(key))
                        (this.cardanoChainsNativeTokens as any)![key] = _data["cardanoChainsNativeTokens"][key] ? _data["cardanoChainsNativeTokens"][key].map((i: any) => NativeTokenDto.fromJS(i)) : [];
                }
            }
            this.bridgingSettings = _data["bridgingSettings"] ? BridgingSettingsDto.fromJS(_data["bridgingSettings"]) : new BridgingSettingsDto();
            if (Array.isArray(_data["enabledChains"])) {
                this.enabledChains = [] as any;
                for (let item of _data["enabledChains"])
                    this.enabledChains!.push(item);
            }
            if (Array.isArray(_data["layerZeroChains"])) {
                this.layerZeroChains = [] as any;
                for (let item of _data["layerZeroChains"])
                    this.layerZeroChains!.push(LayerZeroChainSettingsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SettingsFullResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new SettingsFullResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["runMode"] = this.runMode;
        if (this.cardanoChainsNativeTokens) {
            data["cardanoChainsNativeTokens"] = {};
            for (let key in this.cardanoChainsNativeTokens) {
                if (this.cardanoChainsNativeTokens.hasOwnProperty(key))
                    (data["cardanoChainsNativeTokens"] as any)[key] = (this.cardanoChainsNativeTokens as any)[key];
            }
        }
        data["bridgingSettings"] = this.bridgingSettings ? this.bridgingSettings.toJSON() : undefined as any;
        if (Array.isArray(this.enabledChains)) {
            data["enabledChains"] = [];
            for (let item of this.enabledChains)
                data["enabledChains"].push(item);
        }
        if (Array.isArray(this.layerZeroChains)) {
            data["layerZeroChains"] = [];
            for (let item of this.layerZeroChains)
                data["layerZeroChains"].push(item ? item.toJSON() : undefined as any);
        }
        return data;
    }
}

export interface ISettingsFullResponseDto {
    /** Specifies the current operating mode of the application */
    runMode: string;
    /** For each source chain, defines the native token that will be received on the destination chain */
    cardanoChainsNativeTokens: { [key: string]: NativeTokenDto[]; };
    /** Settings for bridge */
    bridgingSettings: BridgingSettingsDto;
    /** Participating chains in the bridge */
    enabledChains: string[];
    /** LayerZero chains and their configurations */
    layerZeroChains: LayerZeroChainSettingsDto[];

    [key: string]: any;
}

/** Destination chain ID */
export enum ChainApexBridgeEnum {
    Prime = "prime",
    Vector = "vector",
    Nexus = "nexus",
    Cardano = "cardano",
}

export class CreateTransactionDto implements ICreateTransactionDto {
    /** Address that initiates the bridging request on the source chain */
    senderAddress!: string;
    originChain!: ChainApexBridgeEnum;
    destinationChain!: ChainApexBridgeEnum;
    /** Receiver address on destination chain */
    destinationAddress!: string;
    /** Amount to be bridged */
    amount!: string;
    /** Fee covering the submission of the transaction on the destination chain, expressed in Lovelace */
    bridgingFee?: string | undefined;
    /** Fee covering the operational cost of processing the bridging request, expressed in Lovelace */
    operationFee?: string | undefined;
    /** Key used to enable caching of spent UTXOs */
    utxoCacheKey?: string | undefined;
    /** True if the amount is specified in a native token; false if in a currency on source chain */
    isNativeToken!: boolean;

    [key: string]: any;

    constructor(data?: ICreateTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.senderAddress = _data["senderAddress"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.destinationAddress = _data["destinationAddress"];
            this.amount = _data["amount"];
            this.bridgingFee = _data["bridgingFee"];
            this.operationFee = _data["operationFee"];
            this.utxoCacheKey = _data["utxoCacheKey"];
            this.isNativeToken = _data["isNativeToken"];
        }
    }

    static fromJS(data: any): CreateTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["senderAddress"] = this.senderAddress;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["destinationAddress"] = this.destinationAddress;
        data["amount"] = this.amount;
        data["bridgingFee"] = this.bridgingFee;
        data["operationFee"] = this.operationFee;
        data["utxoCacheKey"] = this.utxoCacheKey;
        data["isNativeToken"] = this.isNativeToken;
        return data;
    }
}

export interface ICreateTransactionDto {
    /** Address that initiates the bridging request on the source chain */
    senderAddress: string;
    originChain: ChainApexBridgeEnum;
    destinationChain: ChainApexBridgeEnum;
    /** Receiver address on destination chain */
    destinationAddress: string;
    /** Amount to be bridged */
    amount: string;
    /** Fee covering the submission of the transaction on the destination chain, expressed in Lovelace */
    bridgingFee?: string | undefined;
    /** Fee covering the operational cost of processing the bridging request, expressed in Lovelace */
    operationFee?: string | undefined;
    /** Key used to enable caching of spent UTXOs */
    utxoCacheKey?: string | undefined;
    /** True if the amount is specified in a native token; false if in a currency on source chain */
    isNativeToken: boolean;

    [key: string]: any;
}

export class CreateCardanoTransactionResponseDto implements ICreateCardanoTransactionResponseDto {
    /** Raw transaction data, encoded as a hexadecimal string */
    txRaw!: string;
    /** Transaction hash */
    txHash!: string;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee!: number;
    /** Indicates is fallback mechanism used */
    isFallback!: boolean;
    /** Amount of currency to be bridged, expressed in Lovelace */
    amount!: number;
    /** Amount of native token to be bridged */
    nativeTokenAmount?: number | undefined;

    [key: string]: any;

    constructor(data?: ICreateCardanoTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.txRaw = _data["txRaw"];
            this.txHash = _data["txHash"];
            this.bridgingFee = _data["bridgingFee"];
            this.isFallback = _data["isFallback"];
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
        }
    }

    static fromJS(data: any): CreateCardanoTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCardanoTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["txRaw"] = this.txRaw;
        data["txHash"] = this.txHash;
        data["bridgingFee"] = this.bridgingFee;
        data["isFallback"] = this.isFallback;
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        return data;
    }
}

export interface ICreateCardanoTransactionResponseDto {
    /** Raw transaction data, encoded as a hexadecimal string */
    txRaw: string;
    /** Transaction hash */
    txHash: string;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee: number;
    /** Indicates is fallback mechanism used */
    isFallback: boolean;
    /** Amount of currency to be bridged, expressed in Lovelace */
    amount: number;
    /** Amount of native token to be bridged */
    nativeTokenAmount?: number | undefined;

    [key: string]: any;
}

export class CardanoTransactionFeeResponseDto implements ICardanoTransactionFeeResponseDto {
    /** Transaction fee on the source chain, expressed in Lovelace */
    fee!: number;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee!: number;

    [key: string]: any;

    constructor(data?: ICardanoTransactionFeeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.fee = _data["fee"];
            this.bridgingFee = _data["bridgingFee"];
        }
    }

    static fromJS(data: any): CardanoTransactionFeeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CardanoTransactionFeeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["fee"] = this.fee;
        data["bridgingFee"] = this.bridgingFee;
        return data;
    }
}

export interface ICardanoTransactionFeeResponseDto {
    /** Transaction fee on the source chain, expressed in Lovelace */
    fee: number;
    /** Bridging fee for covering submission on the destination chain, expressed in Lovelace */
    bridgingFee: number;

    [key: string]: any;
}

export class CreateEthTransactionResponseDto implements ICreateEthTransactionResponseDto {
    from!: string;
    to!: string;
    value?: string | undefined;
    data!: string;
    bridgingFee!: string;
    isFallback!: boolean;

    [key: string]: any;

    constructor(data?: ICreateEthTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.from = _data["from"];
            this.to = _data["to"];
            this.value = _data["value"];
            this.data = _data["data"];
            this.bridgingFee = _data["bridgingFee"];
            this.isFallback = _data["isFallback"];
        }
    }

    static fromJS(data: any): CreateEthTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEthTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["from"] = this.from;
        data["to"] = this.to;
        data["value"] = this.value;
        data["data"] = this.data;
        data["bridgingFee"] = this.bridgingFee;
        data["isFallback"] = this.isFallback;
        return data;
    }
}

export interface ICreateEthTransactionResponseDto {
    from: string;
    to: string;
    value?: string | undefined;
    data: string;
    bridgingFee: string;
    isFallback: boolean;

    [key: string]: any;
}

/** Destination chain ID */
export enum ChainEnum {
    Prime = "prime",
    Vector = "vector",
    Nexus = "nexus",
    Cardano = "cardano",
    Base = "base",
    Bsc = "bsc",
}

export class TransactionSubmittedDto implements ITransactionSubmittedDto {
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    /** Transaction hash on source chain */
    originTxHash!: string;
    /** Address that initiated the bridging request on the source chain */
    senderAddress!: string;
    /** Recipient addresses on the destination chain */
    receiverAddrs!: string[];
    /** Amount of currency to be bridged, including bridging fee */
    amount!: string;
    /** Amount of native token to be bridged */
    nativeTokenAmount!: string;
    /** Transaction raw data on source chain */
    txRaw!: string;
    /** Indicates is fallback mechanism used */
    isFallback!: boolean;
    /** Indicates if Layer Zero bridging is used */
    isLayerZero!: boolean;

    [key: string]: any;

    constructor(data?: ITransactionSubmittedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.receiverAddrs = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.originTxHash = _data["originTxHash"];
            this.senderAddress = _data["senderAddress"];
            if (Array.isArray(_data["receiverAddrs"])) {
                this.receiverAddrs = [] as any;
                for (let item of _data["receiverAddrs"])
                    this.receiverAddrs!.push(item);
            }
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
            this.txRaw = _data["txRaw"];
            this.isFallback = _data["isFallback"];
            this.isLayerZero = _data["isLayerZero"];
        }
    }

    static fromJS(data: any): TransactionSubmittedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionSubmittedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["originTxHash"] = this.originTxHash;
        data["senderAddress"] = this.senderAddress;
        if (Array.isArray(this.receiverAddrs)) {
            data["receiverAddrs"] = [];
            for (let item of this.receiverAddrs)
                data["receiverAddrs"].push(item);
        }
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        data["txRaw"] = this.txRaw;
        data["isFallback"] = this.isFallback;
        data["isLayerZero"] = this.isLayerZero;
        return data;
    }
}

export interface ITransactionSubmittedDto {
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    /** Transaction hash on source chain */
    originTxHash: string;
    /** Address that initiated the bridging request on the source chain */
    senderAddress: string;
    /** Recipient addresses on the destination chain */
    receiverAddrs: string[];
    /** Amount of currency to be bridged, including bridging fee */
    amount: string;
    /** Amount of native token to be bridged */
    nativeTokenAmount: string;
    /** Transaction raw data on source chain */
    txRaw: string;
    /** Indicates is fallback mechanism used */
    isFallback: boolean;
    /** Indicates if Layer Zero bridging is used */
    isLayerZero: boolean;

    [key: string]: any;
}

/** Status of bridging request */
export enum TransactionStatusEnum {
    Pending = "Pending",
    DiscoveredOnSource = "DiscoveredOnSource",
    InvalidRequest = "InvalidRequest",
    SubmittedToBridge = "SubmittedToBridge",
    IncludedInBatch = "IncludedInBatch",
    SubmittedToDestination = "SubmittedToDestination",
    FailedToExecuteOnDestination = "FailedToExecuteOnDestination",
    ExecutedOnDestination = "ExecutedOnDestination",
}

export class BridgeTransactionDto implements IBridgeTransactionDto {
    /** Bridging transaction ID */
    id!: number;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress!: string;
    /** Recipient addresses on the destination chain */
    receiverAddresses!: string;
    /** Bridged amount */
    amount!: string;
    /** Bridged native token amount */
    nativeTokenAmount!: string;
    originChain!: ChainEnum;
    destinationChain!: ChainEnum;
    /** Transaction hash on source chain */
    sourceTxHash!: string;
    /** Transaction hash on destination chain */
    destinationTxHash?: string | undefined;
    status!: TransactionStatusEnum;
    /** Transaction creation date */
    createdAt!: Date;
    /** Transaction finalization date */
    finishedAt?: Date | undefined;
    /** Transaction is Layer Zero bridging */
    isLayerZero!: boolean;

    [key: string]: any;

    constructor(data?: IBridgeTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.id = _data["id"];
            this.senderAddress = _data["senderAddress"];
            this.receiverAddresses = _data["receiverAddresses"];
            this.amount = _data["amount"];
            this.nativeTokenAmount = _data["nativeTokenAmount"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.sourceTxHash = _data["sourceTxHash"];
            this.destinationTxHash = _data["destinationTxHash"];
            this.status = _data["status"];
            this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : undefined as any;
            this.finishedAt = _data["finishedAt"] ? new Date(_data["finishedAt"].toString()) : undefined as any;
            this.isLayerZero = _data["isLayerZero"];
        }
    }

    static fromJS(data: any): BridgeTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["id"] = this.id;
        data["senderAddress"] = this.senderAddress;
        data["receiverAddresses"] = this.receiverAddresses;
        data["amount"] = this.amount;
        data["nativeTokenAmount"] = this.nativeTokenAmount;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["sourceTxHash"] = this.sourceTxHash;
        data["destinationTxHash"] = this.destinationTxHash;
        data["status"] = this.status;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : undefined as any;
        data["finishedAt"] = this.finishedAt ? this.finishedAt.toISOString() : undefined as any;
        data["isLayerZero"] = this.isLayerZero;
        return data;
    }
}

export interface IBridgeTransactionDto {
    /** Bridging transaction ID */
    id: number;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress: string;
    /** Recipient addresses on the destination chain */
    receiverAddresses: string;
    /** Bridged amount */
    amount: string;
    /** Bridged native token amount */
    nativeTokenAmount: string;
    originChain: ChainEnum;
    destinationChain: ChainEnum;
    /** Transaction hash on source chain */
    sourceTxHash: string;
    /** Transaction hash on destination chain */
    destinationTxHash?: string | undefined;
    status: TransactionStatusEnum;
    /** Transaction creation date */
    createdAt: Date;
    /** Transaction finalization date */
    finishedAt?: Date | undefined;
    /** Transaction is Layer Zero bridging */
    isLayerZero: boolean;

    [key: string]: any;
}

export class LayerZeroTransferDto implements ILayerZeroTransferDto {
    /** Source chain name where the OFT transfer originates */
    srcChainName!: string;
    /** Destination chain name where the OFT will be received */
    dstChainName!: string;
    /** Address of the OFT contract on the source chain */
    oftAddress!: string;
    /** Amount to transfer in the smallest unit (wei/satoshi equivalent) */
    amount!: string;
    /** Address of the sender wallet */
    from!: string;
    /** Address of the recipient wallet (EVM hex or Solana base58) */
    to!: string;
    /** Whether to validate balances before creating transaction */
    validate?: boolean;
    /** Structured LayerZero execution options as JSON string. EXECUTOR OPTIONS: - lzReceive: Set gas limit and optional native drop for lzReceive execution - nativeDrops: Array of native token drops to specific addresses - composeOptions: Array of compose message execution settings with gas and native drop All numeric values for gas limits and native drops should be strings or numbers. Native drop amounts are in wei (e.g., "1000000000000000" = 0.001 ETH). */
    options?: string;
    /** Compose message for advanced OFT operations (hex encoded) */
    composeMsg?: string;
    /** OFT command for advanced operations (hex encoded) */
    oftCmd?: string;

    [key: string]: any;

    constructor(data?: ILayerZeroTransferDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.validate = false;
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.srcChainName = _data["srcChainName"];
            this.dstChainName = _data["dstChainName"];
            this.oftAddress = _data["oftAddress"];
            this.amount = _data["amount"];
            this.from = _data["from"];
            this.to = _data["to"];
            this.validate = _data["validate"] !== undefined ? _data["validate"] : false;
            this.options = _data["options"];
            this.composeMsg = _data["composeMsg"];
            this.oftCmd = _data["oftCmd"];
        }
    }

    static fromJS(data: any): LayerZeroTransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayerZeroTransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["srcChainName"] = this.srcChainName;
        data["dstChainName"] = this.dstChainName;
        data["oftAddress"] = this.oftAddress;
        data["amount"] = this.amount;
        data["from"] = this.from;
        data["to"] = this.to;
        data["validate"] = this.validate;
        data["options"] = this.options;
        data["composeMsg"] = this.composeMsg;
        data["oftCmd"] = this.oftCmd;
        return data;
    }
}

export interface ILayerZeroTransferDto {
    /** Source chain name where the OFT transfer originates */
    srcChainName: string;
    /** Destination chain name where the OFT will be received */
    dstChainName: string;
    /** Address of the OFT contract on the source chain */
    oftAddress: string;
    /** Amount to transfer in the smallest unit (wei/satoshi equivalent) */
    amount: string;
    /** Address of the sender wallet */
    from: string;
    /** Address of the recipient wallet (EVM hex or Solana base58) */
    to: string;
    /** Whether to validate balances before creating transaction */
    validate?: boolean;
    /** Structured LayerZero execution options as JSON string. EXECUTOR OPTIONS: - lzReceive: Set gas limit and optional native drop for lzReceive execution - nativeDrops: Array of native token drops to specific addresses - composeOptions: Array of compose message execution settings with gas and native drop All numeric values for gas limits and native drops should be strings or numbers. Native drop amounts are in wei (e.g., "1000000000000000" = 0.001 ETH). */
    options?: string;
    /** Compose message for advanced OFT operations (hex encoded) */
    composeMsg?: string;
    /** OFT command for advanced operations (hex encoded) */
    oftCmd?: string;

    [key: string]: any;
}

export class MetadataPropertiesDto implements IMetadataPropertiesDto {
    /** Address of the destination OFT contract */
    dstOftAddress!: string;
    /** Type of the destination OFT adapter */
    dstOftType!: string;
    /** Name of the destination chain */
    dstChainName!: string;
    /** Amount being transferred (in smallest units) */
    amount!: string;
    /** Shared decimals used for cross-chain transfer */
    sharedDecimals!: number;
    /** Local decimals of the token on the source chain */
    localDecimals!: number;

    [key: string]: any;

    constructor(data?: IMetadataPropertiesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.dstOftAddress = _data["dstOftAddress"];
            this.dstOftType = _data["dstOftType"];
            this.dstChainName = _data["dstChainName"];
            this.amount = _data["amount"];
            this.sharedDecimals = _data["sharedDecimals"];
            this.localDecimals = _data["localDecimals"];
        }
    }

    static fromJS(data: any): MetadataPropertiesDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataPropertiesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["dstOftAddress"] = this.dstOftAddress;
        data["dstOftType"] = this.dstOftType;
        data["dstChainName"] = this.dstChainName;
        data["amount"] = this.amount;
        data["sharedDecimals"] = this.sharedDecimals;
        data["localDecimals"] = this.localDecimals;
        return data;
    }
}

export interface IMetadataPropertiesDto {
    /** Address of the destination OFT contract */
    dstOftAddress: string;
    /** Type of the destination OFT adapter */
    dstOftType: string;
    /** Name of the destination chain */
    dstChainName: string;
    /** Amount being transferred (in smallest units) */
    amount: string;
    /** Shared decimals used for cross-chain transfer */
    sharedDecimals: number;
    /** Local decimals of the token on the source chain */
    localDecimals: number;

    [key: string]: any;
}

export class MetadataTimestampsDto implements IMetadataTimestampsDto {
    /** Timestamp of when the transaction was created */
    created!: number;

    [key: string]: any;

    constructor(data?: IMetadataTimestampsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.created = _data["created"];
        }
    }

    static fromJS(data: any): MetadataTimestampsDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataTimestampsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["created"] = this.created;
        return data;
    }
}

export interface IMetadataTimestampsDto {
    /** Timestamp of when the transaction was created */
    created: number;

    [key: string]: any;
}

export class MetadataDto implements IMetadataDto {
    /** Key properties describing the transfer */
    properties!: MetadataPropertiesDto;
    /** Timestamps related to the transfer lifecycle */
    timestamps!: MetadataTimestampsDto;

    [key: string]: any;

    constructor(data?: IMetadataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.properties = new MetadataPropertiesDto();
            this.timestamps = new MetadataTimestampsDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.properties = _data["properties"] ? MetadataPropertiesDto.fromJS(_data["properties"]) : new MetadataPropertiesDto();
            this.timestamps = _data["timestamps"] ? MetadataTimestampsDto.fromJS(_data["timestamps"]) : new MetadataTimestampsDto();
        }
    }

    static fromJS(data: any): MetadataDto {
        data = typeof data === 'object' ? data : {};
        let result = new MetadataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["properties"] = this.properties ? this.properties.toJSON() : undefined as any;
        data["timestamps"] = this.timestamps ? this.timestamps.toJSON() : undefined as any;
        return data;
    }
}

export interface IMetadataDto {
    /** Key properties describing the transfer */
    properties: MetadataPropertiesDto;
    /** Timestamps related to the transfer lifecycle */
    timestamps: MetadataTimestampsDto;

    [key: string]: any;
}

export class PopulatedTransactionDto implements IPopulatedTransactionDto {
    /** Raw transaction calldata to be submitted */
    data!: string;
    /** Destination address for the transaction */
    to!: string;
    /** Value in wei being sent with the transaction */
    value!: string;

    [key: string]: any;

    constructor(data?: IPopulatedTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.data = _data["data"];
            this.to = _data["to"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): PopulatedTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PopulatedTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["data"] = this.data;
        data["to"] = this.to;
        data["value"] = this.value;
        return data;
    }
}

export interface IPopulatedTransactionDto {
    /** Raw transaction calldata to be submitted */
    data: string;
    /** Destination address for the transaction */
    to: string;
    /** Value in wei being sent with the transaction */
    value: string;

    [key: string]: any;
}

export class TransactionDataDto implements ITransactionDataDto {
    /** Populated transaction ready for signing and sending */
    populatedTransaction!: PopulatedTransactionDto;

    [key: string]: any;

    constructor(data?: ITransactionDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.populatedTransaction = new PopulatedTransactionDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.populatedTransaction = _data["populatedTransaction"] ? PopulatedTransactionDto.fromJS(_data["populatedTransaction"]) : new PopulatedTransactionDto();
        }
    }

    static fromJS(data: any): TransactionDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["populatedTransaction"] = this.populatedTransaction ? this.populatedTransaction.toJSON() : undefined as any;
        return data;
    }
}

export interface ITransactionDataDto {
    /** Populated transaction ready for signing and sending */
    populatedTransaction: PopulatedTransactionDto;

    [key: string]: any;
}

export class LayerZeroTransferResponseDto implements ILayerZeroTransferResponseDto {
    /** Transaction history on the destination chain */
    dstTxHistory!: any[][];
    /** Indicates whether the transfer should be simulated before sending */
    shouldSimulate!: boolean;
    /** Type of the response object */
    type!: string;
    /** Timestamp of when this response was created */
    created!: number;
    /** Name of the destination chain for this transfer */
    dstChainName!: string;
    /** Metadata describing the transfer */
    metadata!: MetadataDto;
    /** Transaction data including populated transaction */
    transactionData!: TransactionDataDto;
    /** Type of transaction being executed */
    transactionType!: string;

    [key: string]: any;

    constructor(data?: ILayerZeroTransferResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.dstTxHistory = [];
            this.metadata = new MetadataDto();
            this.transactionData = new TransactionDataDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["dstTxHistory"])) {
                this.dstTxHistory = [] as any;
                for (let item of _data["dstTxHistory"])
                    this.dstTxHistory!.push(item);
            }
            this.shouldSimulate = _data["shouldSimulate"];
            this.type = _data["type"];
            this.created = _data["created"];
            this.dstChainName = _data["dstChainName"];
            this.metadata = _data["metadata"] ? MetadataDto.fromJS(_data["metadata"]) : new MetadataDto();
            this.transactionData = _data["transactionData"] ? TransactionDataDto.fromJS(_data["transactionData"]) : new TransactionDataDto();
            this.transactionType = _data["transactionType"];
        }
    }

    static fromJS(data: any): LayerZeroTransferResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new LayerZeroTransferResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.dstTxHistory)) {
            data["dstTxHistory"] = [];
            for (let item of this.dstTxHistory)
                data["dstTxHistory"].push(item);
        }
        data["shouldSimulate"] = this.shouldSimulate;
        data["type"] = this.type;
        data["created"] = this.created;
        data["dstChainName"] = this.dstChainName;
        data["metadata"] = this.metadata ? this.metadata.toJSON() : undefined as any;
        data["transactionData"] = this.transactionData ? this.transactionData.toJSON() : undefined as any;
        data["transactionType"] = this.transactionType;
        return data;
    }
}

export interface ILayerZeroTransferResponseDto {
    /** Transaction history on the destination chain */
    dstTxHistory: any[][];
    /** Indicates whether the transfer should be simulated before sending */
    shouldSimulate: boolean;
    /** Type of the response object */
    type: string;
    /** Timestamp of when this response was created */
    created: number;
    /** Name of the destination chain for this transfer */
    dstChainName: string;
    /** Metadata describing the transfer */
    metadata: MetadataDto;
    /** Transaction data including populated transaction */
    transactionData: TransactionDataDto;
    /** Type of transaction being executed */
    transactionType: string;

    [key: string]: any;
}

export class BridgeTransactionFilterDto implements IBridgeTransactionFilterDto {
    /** Page number to retrieve */
    page?: number | undefined;
    /** Number of items per page */
    perPage?: number | undefined;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress!: string;
    originChain!: ChainEnum;
    destinationChain?: ChainEnum | undefined;
    /** Minimum amount of currency */
    amountFrom?: string | undefined;
    /** Maximum amount of currency */
    amountTo?: string | undefined;
    /** Minimum amount of native token */
    nativeTokenAmountFrom?: string | undefined;
    /** Maximum amount of native token */
    nativeTokenAmountTo?: string | undefined;
    /** Field by which the results should be sorted */
    orderBy?: string | undefined;
    /** Sort direction */
    order?: string | undefined;
    /** Receiver address on destination chain */
    receiverAddress?: string | undefined;

    [key: string]: any;

    constructor(data?: IBridgeTransactionFilterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.senderAddress = _data["senderAddress"];
            this.originChain = _data["originChain"];
            this.destinationChain = _data["destinationChain"];
            this.amountFrom = _data["amountFrom"];
            this.amountTo = _data["amountTo"];
            this.nativeTokenAmountFrom = _data["nativeTokenAmountFrom"];
            this.nativeTokenAmountTo = _data["nativeTokenAmountTo"];
            this.orderBy = _data["orderBy"];
            this.order = _data["order"];
            this.receiverAddress = _data["receiverAddress"];
        }
    }

    static fromJS(data: any): BridgeTransactionFilterDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionFilterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["senderAddress"] = this.senderAddress;
        data["originChain"] = this.originChain;
        data["destinationChain"] = this.destinationChain;
        data["amountFrom"] = this.amountFrom;
        data["amountTo"] = this.amountTo;
        data["nativeTokenAmountFrom"] = this.nativeTokenAmountFrom;
        data["nativeTokenAmountTo"] = this.nativeTokenAmountTo;
        data["orderBy"] = this.orderBy;
        data["order"] = this.order;
        data["receiverAddress"] = this.receiverAddress;
        return data;
    }
}

export interface IBridgeTransactionFilterDto {
    /** Page number to retrieve */
    page?: number | undefined;
    /** Number of items per page */
    perPage?: number | undefined;
    /** Address that initiated the bridging transaction on the source chain */
    senderAddress: string;
    originChain: ChainEnum;
    destinationChain?: ChainEnum | undefined;
    /** Minimum amount of currency */
    amountFrom?: string | undefined;
    /** Maximum amount of currency */
    amountTo?: string | undefined;
    /** Minimum amount of native token */
    nativeTokenAmountFrom?: string | undefined;
    /** Maximum amount of native token */
    nativeTokenAmountTo?: string | undefined;
    /** Field by which the results should be sorted */
    orderBy?: string | undefined;
    /** Sort direction */
    order?: string | undefined;
    /** Receiver address on destination chain */
    receiverAddress?: string | undefined;

    [key: string]: any;
}

export class BridgeTransactionResponseDto implements IBridgeTransactionResponseDto {
    /** Array of bridging transactions */
    items!: BridgeTransactionDto[];
    /** Current page number */
    page!: number;
    /** Number of items returned per page */
    perPage!: number;
    /** Total number of items */
    total!: number;

    [key: string]: any;

    constructor(data?: IBridgeTransactionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(BridgeTransactionDto.fromJS(item));
            }
            this.page = _data["page"];
            this.perPage = _data["perPage"];
            this.total = _data["total"];
        }
    }

    static fromJS(data: any): BridgeTransactionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new BridgeTransactionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item ? item.toJSON() : undefined as any);
        }
        data["page"] = this.page;
        data["perPage"] = this.perPage;
        data["total"] = this.total;
        return data;
    }
}

export interface IBridgeTransactionResponseDto {
    /** Array of bridging transactions */
    items: BridgeTransactionDto[];
    /** Current page number */
    page: number;
    /** Number of items returned per page */
    perPage: number;
    /** Total number of items */
    total: number;

    [key: string]: any;
}

export class CreateContactDto implements ICreateContactDto {
    /** Full name of the user submitting the message */
    name!: string;
    /** Email address of the user submitting the message */
    email!: string;
    /** Message to be submitted */
    message!: string;

    [key: string]: any;

    constructor(data?: ICreateContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.name = _data["name"];
            this.email = _data["email"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): CreateContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["name"] = this.name;
        data["email"] = this.email;
        data["message"] = this.message;
        return data;
    }
}

export interface ICreateContactDto {
    /** Full name of the user submitting the message */
    name: string;
    /** Email address of the user submitting the message */
    email: string;
    /** Message to be submitted */
    message: string;

    [key: string]: any;
}

export class LockedTokensDto implements ILockedTokensDto {
    /** Mapping of chains to their locked tokens by token type */
    chains!: { [key: string]: { [key: string]: string; }; };
    /** Mapping of total transfered tokens per chain */
    totalTransfered!: { [key: string]: { [key: string]: string; }; };

    [key: string]: any;

    constructor(data?: ILockedTokensDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.chains = {};
            this.totalTransfered = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["chains"]) {
                this.chains = {} as any;
                for (let key in _data["chains"]) {
                    if (_data["chains"].hasOwnProperty(key))
                        (this.chains as any)![key] = _data["chains"][key] !== undefined ? _data["chains"][key] : {};
                }
            }
            if (_data["totalTransfered"]) {
                this.totalTransfered = {} as any;
                for (let key in _data["totalTransfered"]) {
                    if (_data["totalTransfered"].hasOwnProperty(key))
                        (this.totalTransfered as any)![key] = _data["totalTransfered"][key] !== undefined ? _data["totalTransfered"][key] : {};
                }
            }
        }
    }

    static fromJS(data: any): LockedTokensDto {
        data = typeof data === 'object' ? data : {};
        let result = new LockedTokensDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.chains) {
            data["chains"] = {};
            for (let key in this.chains) {
                if (this.chains.hasOwnProperty(key))
                    (data["chains"] as any)[key] = (this.chains as any)[key];
            }
        }
        if (this.totalTransfered) {
            data["totalTransfered"] = {};
            for (let key in this.totalTransfered) {
                if (this.totalTransfered.hasOwnProperty(key))
                    (data["totalTransfered"] as any)[key] = (this.totalTransfered as any)[key];
            }
        }
        return data;
    }
}

export interface ILockedTokensDto {
    /** Mapping of chains to their locked tokens by token type */
    chains: { [key: string]: { [key: string]: string; }; };
    /** Mapping of total transfered tokens per chain */
    totalTransfered: { [key: string]: { [key: string]: string; }; };

    [key: string]: any;
}

export class LockedTokensResponse implements ILockedTokensResponse {
    /** For each chain, the number of locked tokens */
    chains!: { [key: string]: string; };

    [key: string]: any;

    constructor(data?: ILockedTokensResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
        if (!data) {
            this.chains = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["chains"]) {
                this.chains = {} as any;
                for (let key in _data["chains"]) {
                    if (_data["chains"].hasOwnProperty(key))
                        (this.chains as any)![key] = _data["chains"][key];
                }
            }
        }
    }

    static fromJS(data: any): LockedTokensResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LockedTokensResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.chains) {
            data["chains"] = {};
            for (let key in this.chains) {
                if (this.chains.hasOwnProperty(key))
                    (data["chains"] as any)[key] = (this.chains as any)[key];
            }
        }
        return data;
    }
}

export interface ILockedTokensResponse {
    /** For each chain, the number of locked tokens */
    chains: { [key: string]: string; };

    [key: string]: any;
}

export enum GroupBy {
    Hour = "hour",
    Day = "day",
    Week = "week",
    Month = "month",
    Year = "year",
}

export enum LayerZeroChainSettingsDtoChain {
    Prime = "prime",
    Vector = "vector",
    Nexus = "nexus",
    Cardano = "cardano",
    Base = "base",
    Bsc = "bsc",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new ApiException(message, status, response, headers, result);
}